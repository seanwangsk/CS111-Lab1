This code is written by Zhiyang Wang 303991529 and Minhan Xia 204000665
Lab1a
Finished all stuff for Lab1a including subshell function. And also, for
(
  a
  b
)
it will be parsed as (a;b)

Lab1b
Finished all stuff for Lab1b. The command will be executed almost in the same way as bash. One exception is when using a inexisting file as input file or output file, in bash it will not only report error but also throw out the line number of the script. But due to the existing design of main.c, after reading the whole script, the input of execute_command is command_t, which no longer contains line number information, we could not tell line number here.

In our design, system level error such as failing to fork a new process to conduct one simple command will print an error message and skip the execution of current command, but won't stop the whole script 

Lab1c
In Lab1c, we define a data struct call command_unit. Command_unit represents a complete command which is separated by ";" or "\n". Command_unit is the least element to execute. In other words, we paralellize the execution of commands according to each command_unit.

Also, we defined file_tracker which tracks each file in the script. 

For time travel mode, the execution is seperated into two steps.

Step1:
First analyze the file dependency of all command_unit. If a command_unit is blocked, then it is added to the command queue inside of the file_tracker. If the command_unit is not blocked, then the command_unit's block flag should be 0. During this step, all command_unit will also be added into a list.

Step2:
Iteratively scan the command list for command that block counter is 0. Execute them with seperated process. After one command is executed, it will be removed from the command list for all files it used, adjust the commands in the file's blocked list, including modify their block counters and remove them from the files blocked list if the counter now is 0 (means they will no longer wait). And for the next iteration, such commands with block counter now as 0 will be executed.

Iteration will finsih when all commands are removed from the command list.

Notice:
It's our second design. In our first design, we try to merge 2 steps into one that after analyzing the dependency, one command will immediately execute and after executed, it will scan file's blocked list and call other command by itself. But we abandon such design later because it's difficult to share the file status (including blocked list) among child processes. So we have to modify file blocked list in centralized main process. 



Test Report for Lab 1c
(test file in folder Testcases)
Here we conduct three sets of tests. In Test 1, multiple commands read from multiple files. There is no dependency with each other. All commands are expected to execute parallel. The results show that all the commands begin to execute at the same time. All the execution time is as expected.  However, the terminal output may not be the same as sequential execution. 

In test 2, multiple commands read and write to multiple files. Each file may only be written once. There may be multiple file dependency among the commands. The results show that the execution sequence is correct.  In other words, commands are executed by batch as expected. The batch sequence is correct. In each batch, commands are executed parallel.  However, the output sequence within each batch may not be correct. This coincides with the result from Test 1.

In test 3, multiple commands read and write to multiple files. Each file may be written multiple times. There are complicated read and write dependency among the commands. The results show that the batch execution sequence is correct. Still, inside each batch, terminal output may not be correct.

In the Testcases folder, are the test cases we use.




Design1:
1. Create a database to record the application
Table app:	id <app name> type 
Table option:	id <-o> <input?1:0>
Table sequence: id <#>  <input?1:0>

type: by option or by sequence or both

2. Whenever read a new command (Word[0]) if in the data base, then parse it
   If not, parse it into option & sequence
   		record its open syscall
		map the relationship
		update the database

3. Need to do:
	Linux file naming mechanism
	trace the close syscall (dead lock problem)
	whether ptrace will slow down performance
